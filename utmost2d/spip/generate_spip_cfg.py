#!/usr/bin/env python

from astropy.time import Time

import config
import redis
r = redis.Redis(config.redis_db_ip)


def fix_whitespace(s):
    """ Take a multi-line string and fix whitespace for PSRDADA

    Removes trailing and start of line whitespace as per PSRDADA reqs

    Args:
        s (str): String to fix whitespace on

    Returns:
        s (str): multi-line string with fixed whitespace
    """
    sl = s.split('\n')
    sl = [ss.strip()+'\n' for ss in sl]
    return ''.join(sl).strip() +'\n'


def time_to_isodada(t):
    """ Convert ISO/ISOT/astropy.Time into dada ISO- string
        
    Replaces 'T' and ' ' with '-'
    e.g. 2020-10-10-10:00:00.00

    Args:
        t (str or astropy.Time): Time to convert to isodada string
    
    Returns:
        t (str): String in DADA ISO- format
    """
    if isinstance(t, Time):
        t = t.iso.replace(' ', '-')
    else:
        t = t.replace(' ', '-').replace('T', '-')
    return t


def generate_spip_cfg(nsub, first_sub, fw_start_chan=0, nsnap=1, fs=200.0):
    """ Generate config file header for SPIP header.

    Config file required for UDP data capture, and to setup PSRDADA
    ring buffers with correct size

    Args:
        nsub (int): Number of subbands (each of 32 channels).
        first_sub (int): ID of first subband
        fw_start_chan (int): Start channel that the FPGA firmware has configured.
        nsnap (int): Number of SNAP boards (default 1)
        fs (float): FPGA sampling clock in MHz (default 200 MHz)
    
    Returns:
       hdr (str): multi-line header string for PSRDADA header.
    """
    # Hardcoded values used in deriving header params
    bytes_per_second_per_sub = 75000000
    channels_per_sub = 32
    ants_per_snap    = 6
    fft_bw           = fs / 2
    nfft             = 1024
    ndim             = 2
    nbit             = 8
    npol             = 2
    nant             = ants_per_snap * nsnap
    chan_bw          = fft_bw / nfft
    freq             = 800.0 + (first_sub * channels_per_sub) * chan_bw + fw_start_chan * chan_bw
    nframe           = 8    # 8x time steps (FFT windows) per packet
    nchan            = nsub * channels_per_sub
    tsamp            = nfft / fft_bw
    bw               = nchan * fft_bw / nfft
    ## NB: RESOLUTION IS REGENERATED BY PSRDADA!
    ## PSRDADA appears to not include ndim in calculation?
    resolution       = nchan * nant * nframe * npol  # 320 x 6 x 8 x 2 = 30720
    start_channel    = first_sub * channels_per_sub
    end_channel      = start_channel + nsub * channels_per_sub -1
    bytes_per_second = bytes_per_second_per_sub * nsub * nsnap
    file_size        = resolution * 2**16 * ndim
    buf_size         = resolution * 2**10 * ndim
    
    s = """
    HDR_VERSION         1.0
    HDR_SIZE            4096
    BYTES_PER_SECOND    {bytes_per_second}
    FILE_SIZE           {file_size}
    DADA_BUF_SIZE       {buf_size}
    INSTRUMENT          SNAP_MOST
    RECEIVER            SNAP
    TELESCOPE           UTMOST2D
    ADC_CLK             {fs}
    NBIT                {nbit}
    NANT                {nant}
    NCHAN               {nchan}
    NPOL                {npol}
    NDIM                {ndim}
    NSUBBAND            {nsub}
    NSNAP               {nsnap}
    NFRAME              {nframe}
    ORDER               SUBBAND_SNAPBOARD_FRAME_CHAN_ANT_POL_CPLX
    FREQ                {freq}
    CHAN_BW             {chan_bw}
    BW                  {bw}    
    START_CHANNEL       {start_channel}
    END_CHANNEL         {end_channel}
    TSAMP               {tsamp}
    """.format(nant=nant, freq=freq, resolution=resolution, file_size=file_size, 
              buf_size=buf_size, bw=bw, chan_bw=chan_bw, fs=fs,
              ndim=ndim, nchan=nchan, npol=npol, nbit=nbit, nframe=nframe, 
              bytes_per_second=bytes_per_second,
              start_channel=start_channel, end_channel=end_channel, tsamp=tsamp, nsub=nsub, nsnap=nsnap)
    return fix_whitespace(s)


def generate_spip_ip_cfg(host_ip, data_mcast, data_port):
    """ Generate the IP config for SPIP UDP capture

    Args:
        host_ip (str): Host IP address, e.g. 10.0.0.9
        data_mcast (str): Data multicast to subscribe to. Can use + notation,
                          e.g. 239.0.0.1+4 will subscribe to .1 through .5
        data_port (int): Data port, e.g. 23911

    Returns:
        s (str): Multi-line PSRDADA header formatted string
    """
    s = """
    DATA_MCAST          {data_mcast}
    DATA_HOST           {host_ip}
    DATA_PORT           {data_port}
    LOCAL_HOST          {host_ip}
    """.format(data_mcast=data_mcast, data_port=data_port, host_ip=host_ip)
    return fix_whitespace(s)


def generate_spip_obs_cfg(source, ra, dec, observer='FRBOT', project_id='P999'):
    """ Generate observation config params for PSRDADA header

    Args:
        source (str): Source name, e.g. VELA
        ra (str): right ascension in hh:mm:ss.ss e.g. 19:34:00.00
        dec (str): declination in dd:mm:ss.ss e.g. -63:00:00.12
        observer (str): Observer's name. defaults to FRBOT
        project_id (str): Project identifier, defaults to P999

    Returns:
        s (str): Multi-line PSRDADA header formatted string
    """
    s = """
    SOURCE              {source}
    RA                  {ra}
    DEC                 {dec}
    OBSERVER            {observer}
    PID                 {project_id}
    """.format(source=source, ra=ra, dec=dec, observer=observer, project_id=project_id)
    return fix_whitespace(s)


def generate_spip_utc_start(utc=None):
    """ Generate UTC_START for PSRDADA header

    This gets the 'snap:utc_start' parameter that is stored in Redis. This
    parameter is set when FPGA boards are programmed.

    Args:
        utc (str or None): UTC start string, in PSRDADA ISO- format. e.g.
                           2020-10-10-19:34:00.00

    Returns:
        s (str): Multi-line PSRDADA header formatted string
    """
    pkt_start = r.get('snap:utc_start')

    if utc is None:
        t = Time(round(Time.now().unix, 0) + 2, format='unix').iso.replace(' ', '-')
    else:
        t = time_to_isodada(utc)
    s = """
    PKT_START           {pkt_start}
    UTC_START              {t}""".format(t=t, pkt_start=pkt_start)
    return fix_whitespace(s)

def generate_spip_xml_configure(source, ra, dec, project_id="P999", observer="FRBOT", num_stream=8):
    """ Generate SPIP XML configure command. 
    
    Args:
        source (str): Source name, e.g. VELA
        ra (str): right ascension in hh:mm:ss.ss e.g. 19:34:00.00
        dec (str): declination in dd:mm:ss.ss e.g. -63:00:00.12
        observer (str): Observer's name. defaults to FRBOT
        project_id (str): Project identifier, defaults to P999
        num_stream(str): The number of configured SPIP streams, must match SPIP configuration

    Returns:
        s (str): XML message response from SPIP TCS daemon
    """

    xml = "<?xml version='1.0' encoding='ISO-8859-1'?>"
    xml += "<obs_cmd>"
    xml += "<command>configure</command>"

    xml += "<beam_configuration>"
    xml += "<nbeam key='NBEAM'>1</nbeam>"
    xml += "<beam_state_0 key='BEAM_STATE_0' name='1'>1</beam_state_0>"
    xml += "</beam_configuration>"

    xml += "<stream_configuration>"
    xml += "<nstream key='NSTREAM'>" + str(num_stream) + "</nstream>" 
    xml += "</stream_configuration>"

    xml += "<source_parameters>"
    xml += "<name key='SOURCE' epoch='J2000'>" + source + "</name>"
    xml += "<ra key='RA' units='hh:mm:ss'>" + ra + "</ra>"
    xml += "<dec key='DEC' units='dd:mm:ss'>" + dec + "</dec>"
    xml += "</source_parameters>"

    xml += "<calibration_parameters>"
    xml += "<signal key='CAL_SIGNAL'>0</signal>"
    xml += "<freq key='CAL_FREQ' units='hertz'>0</freq>"
    xml += "<phase key='CAL_PHASE' units='periods'>0.0</phase>"
    xml += "<duty_cycle key ='CAL_DUTY_CYCLE' units='periods'>0.5</duty_cycle>"
    xml += "<epoch key='CAL_EPOCH'>None</epoch>"
    xml += "<tsys_avg_time key='TSYS_AVG_TIME' units='seconds'>5</tsys_avg_time>"
    xml += "<tsys_freq_resolution key='TSYS_FREQ_RES' units='MHz'>1</tsys_freq_resolution>"
    xml += "</calibration_parameters>"

    xml += "<observation_parameters>"
    xml += "<observer key='OBSERVER'>" + observer + "</observer>"
    xml += "<project_id key='PID'>" + project_id + "</project_id>"
    xml += "<tobs key='TOBS'>-1</tobs>"
    xml += "<calfreq key='CALFREQ' units='hertz'>0</calfreq>"
    xml += "<utc_start key='UTC_START'>None</utc_start>"
    xml += "<utc_stop key='UTC_STOP'>None</utc_stop>"
    xml += "</observation_parameters>"


    for i in range(num_stream):
        xml += "<stream" + str(i) + ">"
        xml += "<processing_modes>"
        xml += "<fold key='PERFORM_FOLD'>1</fold>"
        xml += "<fb key='PERFORM_FB'>0</fb>"
        xml += "<corr key='PERFORM_CORR'>0</corr>"
        xml += "<search key='PERFORM_SEARCH'>0</search>"
        xml += "</processing_modes>"

        xml += "<custom_parameters>"
        xml += "<junk_param key='JUNK_PARAM'>1</junk_param>"
        xml += "</custom_parameters>"

        # no parameters are passed through to fold yet
        xml += "<fold_processing_parameters>"
        xml += "<output_nchan key='FOLD_OUTNCHAN'>512</output_nchan>"
        xml += "<custom_dm key='FOLD_DM'>-1</custom_dm>"
        xml += "<output_nbin key='FOLD_OUTNBIN'>1024</output_nbin>"
        xml += "<output_tsubint key='FOLD_OUTTSUBINT'>20</output_tsubint>"
        xml += "<output_stokes key='FOLD_OUTSTOKES'>3</output_stokes>"
        xml += "<mode key='MODE'>PSR</mode>"
        xml += "<sk key='FOLD_SK'>0</sk>"
        xml += "<sk_threshold key='FOLD_SK_THRESHOLD'>3</sk_threshold>"
        xml += "<sk_nsamps key='FOLD_SK_NSAMPS'>1024</sk_nsamps>"
        xml += "<append_output key='FOLD_APPEND_OUTPUT'>0</append_output>"
        xml += "</fold_processing_parameters>"
        xml += "</stream" + str(i) + ">"

    xml += "</obs_cmd>"
    return xml


def generate_spip_xml_start(utc, num_stream=8):

    if utc is not None:
        utc = time_to_isodada(utc)

    xml = "<?xml version='1.0' encoding='ISO-8859-1'?>"
    xml += "<obs_cmd>"
    xml += "<command>start</command>"

    xml += "<beam_configuration>"
    xml += "<nbeam key='NBEAM'>1</nbeam>"
    xml += "<beam_state_0 key='BEAM_STATE_0' name='1'>1</beam_state_0>"
    xml += "</beam_configuration>"

    xml += "<stream_configuration>"
    xml += "<nstream key='NSTREAM'>" + str(num_stream) + "</nstream>"
    xml += "</stream_configuration>"

    xml += "<observation_parameters>"
    xml += "<utc_start key='UTC_START'>" + str(utc) + "</utc_start>"
    xml += "</observation_parameters>"

    xml += "</obs_cmd>"
    return xml


def generate_spip_xml_stop(utc, num_stream=8):

    if utc is not None:
        utc = time_to_isodada(utc)

    xml = "<?xml version='1.0' encoding='ISO-8859-1'?>"
    xml += "<obs_cmd>"
    xml += "<command>stop</command>"

    xml += "<beam_configuration>"
    xml += "<nbeam key='NBEAM'>1</nbeam>"
    xml += "<beam_state_0 key='BEAM_STATE_0' name='1'>1</beam_state_0>"
    xml += "</beam_configuration>"

    xml += "<stream_configuration>"
    xml += "<nstream key='NSTREAM'>" + str(num_stream) + "</nstream>"
    xml += "</stream_configuration>"

    xml += "<observation_parameters>"
    xml += "<utc_stop key='UTC_STOP'>" + str(utc) + "</utc_stop>"
    xml += "</observation_parameters>"

    xml += "</obs_cmd>"
    return xml


def generate_dbevent_trigger(start_utc, end_utc, dm=0, snr=0, width=0, beam=0):
    """ Generate event trigger for dada_dbevent

    Args:
        start_utc (astropy.Time): Time to start voltage dump
        end_utc   (astropy.Time): Time to stop voltage dump
        dm (float): Dispersion measure in pc/cm-3 (optional)
        snr (float): Signal to noise ratio (optional)
        width (float): Pulse width (optional)
        beam (int): Beam ID (optional)
    """
    start_utc, end_utc = time_to_isodada(start_utc), time_to_isodada(end_utc)
    n_events = 1   # Currently hardcoded
    pkt_start = r.get('snap:utc_start')
    cmd = """NEVENTS {n_events}
          {pkt_start}
          {start_utc} {end_utc} {dm} {snr} {width} {beam}
          """.format(n_events=n_events, pkt_start=pkt_start,
                     start_utc=start_utc, end_utc=end_utc, 
                     dm=dm, snr=snr, width=width, beam=beam)
    return fix_whitespace(cmd)


if __name__ == "__main__":
    import argparse
    p = argparse.ArgumentParser(description='Generate configuration file (DADA header) for SPIP')
    p.add_argument('cfg_filename', help='Output filename, e.g. config.cfg', default='sx2_bf09_mcast_50mhz.cfg')
    p.add_argument('-n', '--nsub', help='Number of subbands to receive per SNAP', 
                   default=10, type=int)
    p.add_argument('-N', '--nsnap', help='Number of snap boards', 
                    default=1, type=int)
    p.add_argument('-f', '--fsamp', help='ADC clock sampling frequency, default 200 MHz',
                    type=float, default=200.00)
    p.add_argument('-i', '--hostip', help='Host IP address. Default bf09',
                   default='10.0.0.9', type=str)
    p.add_argument('-m', '--mcast', help='Multicast IP group to join, using a.b.c.d+n notation',
                   default='239.17.11.1', type=str)
    p.add_argument('-p', '--port', help='IP port to bind capture to',
                   default=23911, type=int)
    p.add_argument('-c', '--firstsub', help='Index of first subband to capture (0-20)',
                   default=0, type=int)
    p.add_argument('-C', '--fwchan0', help='Index of START_CHANNEL used in F-engine firmware',
                   default=0, type=int)

    args = p.parse_args()
    cfg_filename = args.cfg_filename
    hdr =  generate_spip_cfg(nsub=args.nsub, first_sub=args.firstsub, nsnap=args.nsnap, 
                             fs=args.fsamp, fw_start_chan=args.fwchan0)
    hdr += generate_spip_ip_cfg(args.hostip, args.mcast, args.port)
    #hdr += generate_spip_obs_cfg('FAKE', '00:00:00.00', '-01:02:03.04')
    print(hdr)
    
    with open(cfg_filename, 'w') as fh:
        print("Writing to {}".format(cfg_filename))
        fh.write(hdr)

    
